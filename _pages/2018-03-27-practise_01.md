---
layout: page
title:  "Практика 1"
date:   2018-03-27 21:07:26 +0600
navigation: 1
---

# Практика 1

## Подготовка окружения

1. Установка **Python3** - http://docs.python-guide.org/en/latest/starting/installation/
2. Установка PyCharm Community - https://www.jetbrains.com/pycharm/download/

## Базовый синтаксис Python

```python
####################################################
## 1. Примитивные типы данных и операторы
####################################################

# У вас есть числа
3 #=> 3

# Математика работает вполне ожидаемо
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20

# Кроме деления, которое по умолчанию возвращает число с плавающей запятой
35 / 5  # => 7.0

# Результат целочисленного деления округляется в меньшую сторону
# как для положительных, так и для отрицательных чисел.
5 // 3     # => 1
5.0 // 3.0 # => 1.0 # работает и для чисел с плавающей запятой
-5 // 3  # => -2
-5.0 // 3.0 # => -2.0

# Когда вы используете числа с плавающей запятой,
# результатом будет также число с плавающей запятой
3 * 2.0 # => 6.0

# Остаток от деления
7 % 3 # => 1

# Возведение в степень
2**4 # => 16

# Приоритет операций указывается скобками
(1 + 3) * 2 #=> 8

# Для логических (булевых) значений существует отдельный примитивный тип
True
False

# Для отрицания используется ключевое слово not
not True #=> False
not False #=> True

# Логические операторы
# Обратите внимание: ключевые слова «and» и «or» чувствительны к регистру букв
True and False #=> False
False or True #=> True

# Обратите внимание, что логические операторы используются и с целыми числами
0 and 2 #=> 0
-5 or 0 #=> -5
0 == False #=> True
2 == True #=> False
1 == True #=> True

# Равенство — это ==
1 == 1 #=> True
2 == 1 #=> False

# Неравенство — это !=
1 != 1 #=> False
2 != 1 #=> True

# Ещё немного сравнений
1 < 10 #=> True
1 > 10 #=> False
2 <= 2 #=> True
2 >= 2 #=> True

# Сравнения могут быть записаны цепочкой:
1 < 2 < 3 #=> True
2 < 3 < 2 #=> False

# Строки определяются символом " или '
"Это строка."
'Это тоже строка.'

# И строки тоже могут складываться! Хотя лучше не злоупотребляйте этим.
"Привет " + "мир!" #=> "Привет мир!"

# Со строкой можно работать, как со списком символов
"Это строка"[0] #=> 'Э'

# Метод format используется для форматирования строк:
"{0} могут быть {1}".format("строки", "форматированы")

# Вы можете повторять аргументы форматирования, чтобы меньше печатать.
"Ехал {0} через реку, видит {0} - в реке {1}! Сунул {0} руку в реку, {1} за руку греку цап!".format("грека", "рак")
#=> "Ехал грека через реку, видит грека - в реке рак! Сунул грека руку в реку, рак за руку греку цап!"
# Если вы не хотите считать, можете использовать ключевые слова.
"{name} хочет есть {food}".format(name="Боб", food="лазанью")

# Если ваш код на Python 3 нужно запускать также и под Python 2.5 и ниже,
# вы также можете использовать старый способ форматирования:
"%s можно %s %s способом" % ("строки", "интерполировать", "старым")

# None является объектом
None #=> None

# Не используйте оператор равенства '==' для сравнения
# объектов с None. Используйте для этого 'is'
"etc" is None #=> False
None is None  #=> True

# Оператор «is» проверяет идентичность объектов. Он не
# очень полезен при работе с примитивными типами, но
# зато просто незаменим при работе с объектами.

# None, 0 и пустые строки/списки/словари приводятся к False.
# Все остальные значения равны True
bool(0)  # => False
bool("")  # => False
bool([]) #=> False
bool({}) #=> False


####################################################
## 2. Переменные и коллекции
####################################################

# В Python есть функция Print
print("Я Python. Приятно познакомиться!")

# Объявлять переменные перед инициализацией не нужно.
# По соглашению используется нижний_регистр_с_подчёркиваниями
some_var = 5
some_var #=> 5

# При попытке доступа к неинициализированной переменной
# выбрасывается исключение.
# Об исключениях см. раздел «Поток управления и итерируемые объекты».
some_unknown_var  # Выбрасывает ошибку именования

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненного списка
other_li = [4, 5, 6]

# Объекты добавляются в конец списка методом append
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
# Положим элемент обратно
li.append(3)    # [1, 2, 4, 3].

# Обращайтесь со списком, как с обычным массивом
li[0] #=> 1
# Обратимся к последнему элементу
li[-1] #=> 3

# Попытка выйти за границы массива приведёт к ошибке индекса
li[4] # Выдаёт IndexError

# Можно обращаться к диапазону, используя так называемые срезы
# (Для тех, кто любит математику, это называется замкнуто-открытый интервал).
li[1:3] #=> [2, 4]
# Опускаем начало
li[2:] #=> [4, 3]
# Опускаем конец
li[:3] #=> [1, 2, 4]
# Выбираем каждый второй элемент
li[::2]   # =>[1, 4]
# Переворачиваем список
li[::-1]   # => [3, 4, 2, 1]
# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]

# Удаляем произвольные элементы из списка оператором del
del li[2] # [1, 2, 3]

# Вы можете складывать, или, как ещё говорят, конкатенировать списки
# Обратите внимание: значения li и other_li при этом не изменились.
li + other_li #=> [1, 2, 3, 4, 5, 6]  — Замечание: li и other_li не изменяются

# Объединять списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li #=> True

# Длина списка вычисляется функцией len
len(li) #=> 6


# Кортежи — это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] #=> 1
tup[0] = 3  # Выдаёт TypeError

# Всё то же самое можно делать и с кортежами
len(tup) #=> 3
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)
tup[:2] #=> (1, 2)
2 in tup #=> True

# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4


#  Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {"one": 1, "two": 2, "three": 3}

# Значения извлекаются так же, как из списка, с той лишь разницей,
# что индекс — у словарей он называется ключом — не обязан быть числом
filled_dict["one"] #=> 1

# Все ключи в виде списка получаются с помощью метода keys().
# Его вызов нужно обернуть в list(), так как обратно мы получаем
# итерируемый объект, о которых поговорим позднее.
list(filled_dict.keys())   # => ["three", "two", "one"]
# Замечание: сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.

# Все значения в виде списка можно получить с помощью values().
# И снова нам нужно обернуть вызов в list(), чтобы превратить
# итерируемый объект в список.
list(filled_dict.values())   # => [3, 2, 1]
# То же самое замечание насчёт порядка ключей справедливо и здесь

# При помощи оператора in можно проверять ключи на вхождение в словарь
"one" in filled_dict #=> True
1 in filled_dict #=> False

# Попытка получить значение по несуществующему ключу выбросит ошибку ключа
filled_dict["four"] # KeyError

# Чтобы избежать этого, используйте метод get()
filled_dict.get("one") #=> 1
filled_dict.get("four") #=> None
# Метод get также принимает аргумент по умолчанию, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get("one", 4) #=> 1
filled_dict.get("four", 4) #=> 4

# Метод setdefault вставляет пару ключ-значение, только если такого ключа нет
filled_dict.setdefault("five", 5) #filled_dict["five"] возвращает 5
filled_dict.setdefault("five", 6) #filled_dict["five"] по-прежнему возвращает 5

# Добавление элементов в словарь
filled_dict.update({"four":4}) #=> {"one": 1, "two": 2, "three": 3, "four": 4}
#filled_dict["four"] = 4  # Другой способ добавления элементов

# Удаляйте ключи из словаря с помощью оператора del
del filled_dict["one"]  # Удаляет ключ «one» из словаря


# Множества содержат... ну, в общем, множества
empty_set = set()
# Инициализация множества набором значений.
# Да, оно выглядит примерно как словарь… ну извините, так уж вышло.
filled_set = {1, 2, 2, 3, 4} # => {1, 2, 3, 4}

# Множеству можно назначать новую переменную
filled_set = some_set

# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}

# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False


####################################################
## 3. Поток управления и итерируемые объекты
####################################################

# Для начала заведём переменную
some_var = 5

# Так выглядит выражение if. Отступы в python очень важны!
# результат: «some_var меньше, чем 10»
if some_var > 10:
    print("some_var намного больше, чем 10.")
elif some_var < 10:    # Выражение elif необязательно.
    print("some_var меньше, чем 10.")
else:           # Это тоже необязательно.
    print("some_var равно 10.")


# Циклы For проходят по спискам. Результат:
    # собака — это млекопитающее
    # кошка — это млекопитающее
    # мышь — это млекопитающее
for animal in ["собака", "кошка", "мышь"]:
    # Можете использовать format() для интерполяции форматированных строк
    print("{} — это млекопитающее".format(animal))

"""
«range(число)» возвращает список чисел
от нуля до заданного числа
Результат:
    0
    1
    2
    3
"""
for i in range(4):
    print(i)

"""
Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
Результат:
    0
    1
    2
    3
"""
x = 0
while x < 4:
    print(x)
    x += 1  # Краткая запись для x = x + 1

# Используйте def для создания новых функций
def add(x, y):
    print("x равен %s, а y равен %s" % (x, y))
    return x + y    # Возвращайте результат с помощью ключевого слова return

# Вызов функции с аргументами
add(5, 6) #=> выводит «x равен 5, а y равен 6» и возвращает 11

# Другой способ вызова функции — вызов с именованными аргументами
add(y=6, x=5)   # Именованные аргументы можно указывать в любом порядке.

# Вы можете определить функцию, принимающую переменное число аргументов
def varargs(*args):
    return args

varargs(1, 2, 3) #=> (1,2,3)


# А также можете определить функцию, принимающую переменное число
# именованных аргументов
def keyword_args(**kwargs):
    return kwargs

# Вызовем эту функцию и посмотрим, что из этого получится
keyword_args(big="foot", loch="ness") #=> {"big": "foot", "loch": "ness"}

# Если хотите, можете использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
"""
all_the_args(1, 2, a=3, b=4) выводит:
    (1, 2)
    {"a": 3, "b": 4}
"""

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для распаковки кортежей и ** для распаковки словарей
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # эквивалентно foo(1, 2, 3, 4)
all_the_args(**kwargs) # эквивалентно foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалентно foo(1, 2, 3, 4, a=3, b=4)
```

## Задание в классе

### REPLS as calculator

Запустить REPL и потыкать как калькулятор. Понять как делать арифметические операции, целочисленное деление. Как возводить в степень, как создать список, кортеж, таблицу.

### FizzBuzz

Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»

---

## Домашнее задание

### Чтение

1. Читаем полностью весь Python StyleGuide [PEP8](https://www.python.org/dev/peps/pep-0008/). Можно на [русском языке](http://pep8.ru/doc/pep8/). На следющей практике будет тест на знание этого стайл гайда.

2. Читаем [Zen of Python](https://ru.wikipedia.org/wiki/Python#.D0.A4.D0.B8.D0.BB.D0.BE.D1.81.D0.BE.D1.84.D0.B8.D1.8F). Буду спрашивать, что для вас значит каждое из утверждений.

3. Читаем список встроенных функций в питоне3 - https://docs.python.org/3/library/functions.html. Попробуйте эти функции в консоли питона.

### Программирование

#### Квадратное уравнение

Напишите программу, которая вычисляет корни квадратного уравнения методом дискриминанта. Примечание: пусть дано уравнение $$ax ^ 2 + bx+c = 0$$. Создайте как минимум функцию `def quadratic_equation(a, b, c)`, которая возвращает найденные корни. Функция не должна падать с исключениями. Внутри функции нельзя использовать функции ввод-вывода. Разрешено использовать только пакет `math` для вычисления квадратного корня. Обработайте различные граничные условия. Используйте код ниже для тестирования. Вы можете добавить свои тест кейсы.

```python
def quadratic_equation(a, b, c):
  pass # тут ваш код


cases = [((1, 0, -1), (1,-1)), ((1, 0, 2), None), ((1, 0, 0), (0)), ((1, 1, -2), (1, -2))]
for case in cases:
    a, b, c = case[0]
    res = quadratic_equation(a, b, c)
    print("Expected: {}. Got: {}. Input: {}. Assert: {}".format(case[1], res, case[0], res == case[1]))
```
